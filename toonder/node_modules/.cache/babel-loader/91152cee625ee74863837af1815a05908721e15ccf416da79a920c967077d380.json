{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint, options) {\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n      this.disconnect();\n      this.connect();\n    }), this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = error => this._onConnError(error);\n      this.conn.onmessage = event => this._onConnMessage(event);\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n      this.conn = null;\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n    }\n  }\n  /**\n   * Returns all created channels\n   */\n  getChannels() {\n    return this.channels;\n  }\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  removeChannel(channel) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const status = yield channel.unsubscribe();\n      if (this.channels.length === 0) {\n        this.disconnect();\n      }\n      return status;\n    });\n  }\n  /**\n   * Unsubscribes and removes all channels\n   */\n  removeAllChannels() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const values_1 = yield Promise.all(this.channels.map(channel => channel.unsubscribe()));\n      this.disconnect();\n      return values_1;\n    });\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  channel(topic) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    if (!this.isConnected()) {\n      this.connect();\n    }\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n    this.channels.push(chan);\n    return chan;\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    let callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)();\n        if (isThrottled) {\n          return 'rate limited';\n        }\n      } else {\n        callback();\n      }\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token) {\n    this.accessToken = token;\n    this.channels.forEach(channel => {\n      token && channel.updateJoinPayload({\n        access_token: token\n      });\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, {\n          access_token: token\n        });\n      }\n    });\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());\n  }\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  _endPointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /** @internal */\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n  _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`);\n    this._flushSendBuffer();\n    this.reconnectTimer.reset();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n  _onConnError(error) {\n    this.log('transport', error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  /** @internal */\n  _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /** @internal */\n  _sendHeartbeat() {\n    var _a;\n    if (!this.isConnected()) {\n      return;\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null;\n      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n      return;\n    }\n    this.pendingHeartbeatRef = this._makeRef();\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef\n    });\n    this.setAuth(this.accessToken);\n  }\n  /** @internal */\n  _throttle(callback) {\n    let eventsPerSecondLimitMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;\n    return () => {\n      if (this.inThrottle) return true;\n      callback();\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true;\n        setTimeout(() => {\n          this.inThrottle = false;\n        }, eventsPerSecondLimitMs);\n      }\n      return false;\n    };\n  }\n}","map":{"version":3,"names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","constructor","endPoint","options","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","eventsPerSecondLimitMs","inThrottle","websocket","Object","assign","eventsPerSecond","_a","Math","floor","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","__awaiter","disconnect","connect","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","clearInterval","reset","getChannels","removeChannel","channel","status","unsubscribe","length","removeAllChannels","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","arguments","config","chan","push","result","send","includes","isThrottled","_throttle","setAuth","token","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","_makeRef","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","_appendParams","vsn","rawMessage","type","_isMember","_trigger","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","setTimeout"],"sources":["C:\\Temp\\2023_1_Toonder\\toonder\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  eventsPerSecondLimitMs: number = 100\n  inThrottle: boolean = false\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const eventsPerSecond = options?.params?.eventsPerSecond\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this._onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    if (!this.isConnected()) {\n      this.connect()\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): 'rate limited' | void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)()\n        if (isThrottled) {\n          return 'rate limited'\n        }\n      } else {\n        callback()\n      }\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n\n  /** @internal */\n  private _throttle(\n    callback: Function,\n    eventsPerSecondLimitMs: number = this.eventsPerSecondLimitMs\n  ): () => boolean {\n    return () => {\n      if (this.inThrottle) return true\n\n      callback()\n\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true\n\n        setTimeout(() => {\n          this.inThrottle = false\n        }, eventsPerSecondLimitMs)\n      }\n\n      return false\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}